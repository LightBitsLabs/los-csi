// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api-service/statisticsapi.proto

package durospb

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

///////////////////////////////////////
//   API structures (external facing)
///////////////////////////////////////
type ClusterStatisticsApi struct {
	// Installed Physical Storage
	//
	// All installed SSDs capacities over all servers in cluster, given in bytes.
	InstalledPhysicalStorage uint64 `protobuf:"varint,1,opt,name=installedPhysicalStorage,proto3" json:"installedPhysicalStorage,omitempty"`
	// Total Attached Physical Storage
	//
	// Sum of all managed and healthy SSDs capacities, given in bytes.
	ManagedPhysicalStorage uint64 `protobuf:"varint,2,opt,name=managedPhysicalStorage,proto3" json:"managedPhysicalStorage,omitempty"`
	// Effective Physical Storage
	//
	// Effective Physical storage excluding overhead of OVP and Parity, given in bytes.
	EffectivePhysicalStorage uint64 `protobuf:"varint,3,opt,name=effectivePhysicalStorage,proto3" json:"effectivePhysicalStorage,omitempty"`
	// Logical Storage
	//
	// Sum of capacities of all allocated volumes, given in bytes.
	LogicalStorage uint64 `protobuf:"varint,4,opt,name=logicalStorage,proto3" json:"logicalStorage,omitempty"`
	// Logical Used Storage
	//
	// Logical storage space used by all volumes (n of LBAs x 4096), given in bytes.
	LogicalUsedStorage uint64 `protobuf:"varint,5,opt,name=logicalUsedStorage,proto3" json:"logicalUsedStorage,omitempty"`
	// Physical Used Storage Excluding Parity
	//
	// Physical storage space occupied by all volumes (data only), given in bytes.
	PhysicalUsedStorage uint64 `protobuf:"varint,6,opt,name=physicalUsedStorage,proto3" json:"physicalUsedStorage,omitempty"`
	// Physical Used Storage
	//
	// Physical storage space occupied by all data including Parity overhead when EC enabled (physical n*disks/(n*disks -1)), given in bytes.
	PhysicalUsedStorageIncludingParity uint64 `protobuf:"varint,7,opt,name=physicalUsedStorageIncludingParity,proto3" json:"physicalUsedStorageIncludingParity,omitempty"`
	// Free Physical Storage
	//
	// Free storage before entering to read-only mode , given in bytes.
	FreePhysicalStorage uint64 `protobuf:"varint,8,opt,name=freePhysicalStorage,proto3" json:"freePhysicalStorage,omitempty"`
	// Estimated Free Logical Storage
	//
	// Estimated free storage before entering to read-only mode assuming current compression ratio, given in bytes.
	EstimatedFreeLogicalStorage uint64 `protobuf:"varint,9,opt,name=estimatedFreeLogicalStorage,proto3" json:"estimatedFreeLogicalStorage,omitempty"`
	// Estimated Total Available Logical Storage
	//
	// Estimate of total available logical storage based on current compression ratio (effective * compression)
	EstimatedLogicalStorage uint64 `protobuf:"varint,10,opt,name=estimatedLogicalStorage,proto3" json:"estimatedLogicalStorage,omitempty"`
	// commpression ratio
	//
	// compression ratio logicalUsedStorage/physicalUsedStorage
	CompressionRatio     float64  `protobuf:"fixed64,11,opt,name=compressionRatio,proto3" json:"compressionRatio,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterStatisticsApi) Reset()         { *m = ClusterStatisticsApi{} }
func (m *ClusterStatisticsApi) String() string { return proto.CompactTextString(m) }
func (*ClusterStatisticsApi) ProtoMessage()    {}
func (*ClusterStatisticsApi) Descriptor() ([]byte, []int) {
	return fileDescriptor_81d153188e848b89, []int{0}
}

func (m *ClusterStatisticsApi) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClusterStatisticsApi.Unmarshal(m, b)
}
func (m *ClusterStatisticsApi) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClusterStatisticsApi.Marshal(b, m, deterministic)
}
func (m *ClusterStatisticsApi) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterStatisticsApi.Merge(m, src)
}
func (m *ClusterStatisticsApi) XXX_Size() int {
	return xxx_messageInfo_ClusterStatisticsApi.Size(m)
}
func (m *ClusterStatisticsApi) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterStatisticsApi.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterStatisticsApi proto.InternalMessageInfo

func (m *ClusterStatisticsApi) GetInstalledPhysicalStorage() uint64 {
	if m != nil {
		return m.InstalledPhysicalStorage
	}
	return 0
}

func (m *ClusterStatisticsApi) GetManagedPhysicalStorage() uint64 {
	if m != nil {
		return m.ManagedPhysicalStorage
	}
	return 0
}

func (m *ClusterStatisticsApi) GetEffectivePhysicalStorage() uint64 {
	if m != nil {
		return m.EffectivePhysicalStorage
	}
	return 0
}

func (m *ClusterStatisticsApi) GetLogicalStorage() uint64 {
	if m != nil {
		return m.LogicalStorage
	}
	return 0
}

func (m *ClusterStatisticsApi) GetLogicalUsedStorage() uint64 {
	if m != nil {
		return m.LogicalUsedStorage
	}
	return 0
}

func (m *ClusterStatisticsApi) GetPhysicalUsedStorage() uint64 {
	if m != nil {
		return m.PhysicalUsedStorage
	}
	return 0
}

func (m *ClusterStatisticsApi) GetPhysicalUsedStorageIncludingParity() uint64 {
	if m != nil {
		return m.PhysicalUsedStorageIncludingParity
	}
	return 0
}

func (m *ClusterStatisticsApi) GetFreePhysicalStorage() uint64 {
	if m != nil {
		return m.FreePhysicalStorage
	}
	return 0
}

func (m *ClusterStatisticsApi) GetEstimatedFreeLogicalStorage() uint64 {
	if m != nil {
		return m.EstimatedFreeLogicalStorage
	}
	return 0
}

func (m *ClusterStatisticsApi) GetEstimatedLogicalStorage() uint64 {
	if m != nil {
		return m.EstimatedLogicalStorage
	}
	return 0
}

func (m *ClusterStatisticsApi) GetCompressionRatio() float64 {
	if m != nil {
		return m.CompressionRatio
	}
	return 0
}

type NodeStatisticsApi struct {
	// Total Attached Physical Total Storage
	//
	// Sum of all managed and healthy SSDs capacities, given in bytes.
	ManagedPhysicalStorage uint64 `protobuf:"varint,1,opt,name=managedPhysicalStorage,proto3" json:"managedPhysicalStorage,omitempty"`
	// Effective Physical Storage
	//
	// Effective Physical storage excluding overhead of OVP and Parity, given in bytes.
	EffectivePhysicalStorage uint64 `protobuf:"varint,2,opt,name=effectivePhysicalStorage,proto3" json:"effectivePhysicalStorage,omitempty"`
	// Logical Storage
	//
	// Sum of capacities of all allocated volumes, given in bytes.
	LogicalStorage uint64 `protobuf:"varint,3,opt,name=logicalStorage,proto3" json:"logicalStorage,omitempty"`
	// Logical Used Storage
	//
	// Logical storage space used by all volumes (n of LBAs x 4096), given in bytes.
	LogicalUsedStorage uint64 `protobuf:"varint,4,opt,name=logicalUsedStorage,proto3" json:"logicalUsedStorage,omitempty"`
	// Physical Used Storage Excluding Parity
	//
	// Physical storage space occupied by all volumes (data only), given in bytes.
	PhysicalUsedStorage uint64 `protobuf:"varint,5,opt,name=physicalUsedStorage,proto3" json:"physicalUsedStorage,omitempty"`
	// Physical Used Storage
	//
	// Physical storage space occupied by all data including Parity overhead when EC enabled (physical n*disks/(n*disks -1)), given in bytes.
	PhysicalUsedStorageIncludingParity uint64 `protobuf:"varint,6,opt,name=physicalUsedStorageIncludingParity,proto3" json:"physicalUsedStorageIncludingParity,omitempty"`
	// Free Physical Storage
	//
	// Free storage before entering to read-only mode, given in bytes.
	FreePhysicalStorage uint64 `protobuf:"varint,7,opt,name=freePhysicalStorage,proto3" json:"freePhysicalStorage,omitempty"`
	// Estimated Free Logical Storage
	//
	// Estimated free storage before entering to read-only mode assuming current compression ratio, given in bytes.
	EstimatedFreeLogicalStorage uint64 `protobuf:"varint,8,opt,name=estimatedFreeLogicalStorage,proto3" json:"estimatedFreeLogicalStorage,omitempty"`
	// Estimated Total Available Logical Storage
	//
	// Estimate of total available logical storage based on current compression ratio (effective * compression)
	EstimatedLogicalStorage uint64 `protobuf:"varint,9,opt,name=estimatedLogicalStorage,proto3" json:"estimatedLogicalStorage,omitempty"`
	// commpression ratio
	//
	// compression ratio logicalUsedStorage/physicalUsedStorage
	CompressionRatio     float64  `protobuf:"fixed64,10,opt,name=compressionRatio,proto3" json:"compressionRatio,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeStatisticsApi) Reset()         { *m = NodeStatisticsApi{} }
func (m *NodeStatisticsApi) String() string { return proto.CompactTextString(m) }
func (*NodeStatisticsApi) ProtoMessage()    {}
func (*NodeStatisticsApi) Descriptor() ([]byte, []int) {
	return fileDescriptor_81d153188e848b89, []int{1}
}

func (m *NodeStatisticsApi) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeStatisticsApi.Unmarshal(m, b)
}
func (m *NodeStatisticsApi) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeStatisticsApi.Marshal(b, m, deterministic)
}
func (m *NodeStatisticsApi) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeStatisticsApi.Merge(m, src)
}
func (m *NodeStatisticsApi) XXX_Size() int {
	return xxx_messageInfo_NodeStatisticsApi.Size(m)
}
func (m *NodeStatisticsApi) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeStatisticsApi.DiscardUnknown(m)
}

var xxx_messageInfo_NodeStatisticsApi proto.InternalMessageInfo

func (m *NodeStatisticsApi) GetManagedPhysicalStorage() uint64 {
	if m != nil {
		return m.ManagedPhysicalStorage
	}
	return 0
}

func (m *NodeStatisticsApi) GetEffectivePhysicalStorage() uint64 {
	if m != nil {
		return m.EffectivePhysicalStorage
	}
	return 0
}

func (m *NodeStatisticsApi) GetLogicalStorage() uint64 {
	if m != nil {
		return m.LogicalStorage
	}
	return 0
}

func (m *NodeStatisticsApi) GetLogicalUsedStorage() uint64 {
	if m != nil {
		return m.LogicalUsedStorage
	}
	return 0
}

func (m *NodeStatisticsApi) GetPhysicalUsedStorage() uint64 {
	if m != nil {
		return m.PhysicalUsedStorage
	}
	return 0
}

func (m *NodeStatisticsApi) GetPhysicalUsedStorageIncludingParity() uint64 {
	if m != nil {
		return m.PhysicalUsedStorageIncludingParity
	}
	return 0
}

func (m *NodeStatisticsApi) GetFreePhysicalStorage() uint64 {
	if m != nil {
		return m.FreePhysicalStorage
	}
	return 0
}

func (m *NodeStatisticsApi) GetEstimatedFreeLogicalStorage() uint64 {
	if m != nil {
		return m.EstimatedFreeLogicalStorage
	}
	return 0
}

func (m *NodeStatisticsApi) GetEstimatedLogicalStorage() uint64 {
	if m != nil {
		return m.EstimatedLogicalStorage
	}
	return 0
}

func (m *NodeStatisticsApi) GetCompressionRatio() float64 {
	if m != nil {
		return m.CompressionRatio
	}
	return 0
}

type VolumeStatisticsApi struct {
	// Logical Used Storage
	//
	// Logical storage space used by volume, given in bytes.
	LogicalUsedStorage uint64 `protobuf:"varint,1,opt,name=logicalUsedStorage,proto3" json:"logicalUsedStorage,omitempty"`
	// Physical Used Storage
	//
	// Physical storage space used by volume excluding parity, given in bytes.
	PhysicalUsedStorage uint64 `protobuf:"varint,2,opt,name=physicalUsedStorage,proto3" json:"physicalUsedStorage,omitempty"`
	// commpression ratio
	//
	// compression ratio logicalUsedStorage/physicalUsedStorage
	CompressionRatio     float64  `protobuf:"fixed64,3,opt,name=compressionRatio,proto3" json:"compressionRatio,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeStatisticsApi) Reset()         { *m = VolumeStatisticsApi{} }
func (m *VolumeStatisticsApi) String() string { return proto.CompactTextString(m) }
func (*VolumeStatisticsApi) ProtoMessage()    {}
func (*VolumeStatisticsApi) Descriptor() ([]byte, []int) {
	return fileDescriptor_81d153188e848b89, []int{2}
}

func (m *VolumeStatisticsApi) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeStatisticsApi.Unmarshal(m, b)
}
func (m *VolumeStatisticsApi) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeStatisticsApi.Marshal(b, m, deterministic)
}
func (m *VolumeStatisticsApi) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeStatisticsApi.Merge(m, src)
}
func (m *VolumeStatisticsApi) XXX_Size() int {
	return xxx_messageInfo_VolumeStatisticsApi.Size(m)
}
func (m *VolumeStatisticsApi) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeStatisticsApi.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeStatisticsApi proto.InternalMessageInfo

func (m *VolumeStatisticsApi) GetLogicalUsedStorage() uint64 {
	if m != nil {
		return m.LogicalUsedStorage
	}
	return 0
}

func (m *VolumeStatisticsApi) GetPhysicalUsedStorage() uint64 {
	if m != nil {
		return m.PhysicalUsedStorage
	}
	return 0
}

func (m *VolumeStatisticsApi) GetCompressionRatio() float64 {
	if m != nil {
		return m.CompressionRatio
	}
	return 0
}

func init() {
	proto.RegisterType((*ClusterStatisticsApi)(nil), "lightbits.api.duros.v1.ClusterStatisticsApi")
	proto.RegisterType((*NodeStatisticsApi)(nil), "lightbits.api.duros.v1.NodeStatisticsApi")
	proto.RegisterType((*VolumeStatisticsApi)(nil), "lightbits.api.duros.v1.VolumeStatisticsApi")
}

func init() { proto.RegisterFile("api-service/statisticsapi.proto", fileDescriptor_81d153188e848b89) }

var fileDescriptor_81d153188e848b89 = []byte{
	// 404 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x94, 0xcd, 0x6a, 0xea, 0x40,
	0x14, 0xc7, 0x89, 0xc6, 0xaf, 0xb9, 0xdc, 0xaf, 0xf1, 0xe2, 0x0d, 0xdc, 0xc5, 0x15, 0x17, 0x17,
	0xb9, 0xd0, 0xb4, 0xa5, 0x50, 0x4a, 0xbb, 0xe9, 0x07, 0x14, 0x0a, 0x45, 0x44, 0x69, 0x17, 0xdd,
	0x8d, 0xc9, 0x31, 0x1e, 0x98, 0x64, 0xc2, 0xcc, 0x44, 0xf0, 0x79, 0xfa, 0x18, 0x7d, 0xb3, 0xae,
	0x8a, 0xa3, 0x15, 0x8d, 0x49, 0x69, 0x74, 0x93, 0xc5, 0xf9, 0x9f, 0x5f, 0xe6, 0x30, 0xe7, 0xc7,
	0x90, 0xbf, 0x2c, 0xc6, 0x03, 0x05, 0x72, 0x8a, 0x1e, 0x1c, 0x2a, 0xcd, 0x34, 0x2a, 0x8d, 0x9e,
	0x62, 0x31, 0xba, 0xb1, 0x14, 0x5a, 0xd0, 0x16, 0xc7, 0x60, 0xa2, 0x47, 0xa8, 0x95, 0x3b, 0x2f,
	0xfa, 0x89, 0x14, 0xca, 0x9d, 0x1e, 0x77, 0x5e, 0x6d, 0xf2, 0xeb, 0x86, 0x27, 0x4a, 0x83, 0x1c,
	0xae, 0xb0, 0xab, 0x18, 0xe9, 0x39, 0x71, 0x30, 0x52, 0x9a, 0x71, 0x0e, 0x7e, 0x7f, 0x32, 0x53,
	0xe8, 0x31, 0x3e, 0xd4, 0x42, 0xb2, 0x00, 0x1c, 0xab, 0x6d, 0x75, 0xed, 0x41, 0x6e, 0x4e, 0x4f,
	0x49, 0x2b, 0x64, 0x11, 0x0b, 0xb6, 0xc9, 0x92, 0x21, 0x73, 0xd2, 0xf9, 0x99, 0x30, 0x1e, 0x83,
	0xa7, 0x71, 0x0a, 0x69, 0xb2, 0xbc, 0x38, 0x33, 0x2f, 0xa7, 0xff, 0xc8, 0x37, 0x2e, 0x82, 0x75,
	0xc2, 0x36, 0x44, 0xaa, 0x4a, 0x5d, 0x42, 0x97, 0x95, 0x07, 0x05, 0xfe, 0x7b, 0x6f, 0xc5, 0xf4,
	0x66, 0x24, 0xf4, 0x88, 0x34, 0xe3, 0xe5, 0x51, 0xeb, 0x40, 0xd5, 0x00, 0x59, 0x11, 0xed, 0x91,
	0x4e, 0x46, 0xf9, 0x2e, 0xf2, 0x78, 0xe2, 0x63, 0x14, 0xf4, 0x99, 0x44, 0x3d, 0x73, 0x6a, 0xe6,
	0x07, 0x9f, 0xe8, 0x9c, 0x4f, 0x30, 0x96, 0xb0, 0x75, 0x21, 0xf5, 0xc5, 0x04, 0x19, 0x11, 0xbd,
	0x24, 0x7f, 0x40, 0x69, 0x0c, 0x99, 0x06, 0xff, 0x56, 0x02, 0xdc, 0x6f, 0x5e, 0x4c, 0xc3, 0x90,
	0x1f, 0xb5, 0xd0, 0x33, 0xf2, 0x7b, 0x15, 0xa7, 0x68, 0x62, 0xe8, 0xbc, 0x98, 0xfe, 0x27, 0x3f,
	0x3c, 0x11, 0xc6, 0x12, 0x94, 0x42, 0x11, 0x0d, 0x98, 0x46, 0xe1, 0x7c, 0x69, 0x5b, 0x5d, 0x6b,
	0xb0, 0x55, 0xef, 0xbc, 0xd8, 0xe4, 0x67, 0x4f, 0xf8, 0xb0, 0x69, 0x5e, 0xbe, 0x3d, 0xd6, 0xce,
	0xf6, 0x94, 0x0a, 0xdb, 0x53, 0x2e, 0x60, 0x8f, 0x5d, 0xd4, 0x9e, 0xca, 0xbe, 0xf6, 0x54, 0xf7,
	0xb5, 0xa7, 0xb6, 0xb3, 0x3d, 0xf5, 0xbd, 0xec, 0x69, 0x14, 0xb7, 0x87, 0xe4, 0xd8, 0xf3, 0x6c,
	0x91, 0xe6, 0xa3, 0xe0, 0x49, 0x98, 0xf2, 0x27, 0x7b, 0x47, 0x56, 0xd1, 0x1d, 0x95, 0xf2, 0x77,
	0x94, 0x35, 0x65, 0x39, 0x7b, 0xca, 0xeb, 0xef, 0x4f, 0x5f, 0xcd, 0x63, 0x7b, 0x61, 0xbe, 0xf1,
	0x68, 0x54, 0x35, 0x0f, 0xf2, 0xc9, 0x5b, 0x00, 0x00, 0x00, 0xff, 0xff, 0x74, 0x09, 0x03, 0x76,
	0xb3, 0x05, 0x00, 0x00,
}
