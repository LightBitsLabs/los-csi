// Code generated by protoc-gen-go. DO NOT EDIT.
// source: common_apis/volume.proto

package common_apis

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ProtectionStateEnum int32

const (
	ProtectionStateEnum_Unknown        ProtectionStateEnum = 0
	ProtectionStateEnum_FullyProtected ProtectionStateEnum = 1
	ProtectionStateEnum_Degraded       ProtectionStateEnum = 2
	ProtectionStateEnum_ReadOnly       ProtectionStateEnum = 3
	ProtectionStateEnum_NotAvailable   ProtectionStateEnum = 4
)

var ProtectionStateEnum_name = map[int32]string{
	0: "Unknown",
	1: "FullyProtected",
	2: "Degraded",
	3: "ReadOnly",
	4: "NotAvailable",
}

var ProtectionStateEnum_value = map[string]int32{
	"Unknown":        0,
	"FullyProtected": 1,
	"Degraded":       2,
	"ReadOnly":       3,
	"NotAvailable":   4,
}

func (x ProtectionStateEnum) String() string {
	return proto.EnumName(ProtectionStateEnum_name, int32(x))
}

func (ProtectionStateEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa16fa2085166c06, []int{0}
}

type DurosVolume_ProtocolEnum int32

const (
	DurosVolume_ProtocolTCP DurosVolume_ProtocolEnum = 0
)

var DurosVolume_ProtocolEnum_name = map[int32]string{
	0: "ProtocolTCP",
}

var DurosVolume_ProtocolEnum_value = map[string]int32{
	"ProtocolTCP": 0,
}

func (x DurosVolume_ProtocolEnum) String() string {
	return proto.EnumName(DurosVolume_ProtocolEnum_name, int32(x))
}

func (DurosVolume_ProtocolEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa16fa2085166c06, []int{0, 0}
}

type Volume_StateEnum int32

const (
	Volume_Unknown  Volume_StateEnum = 0
	Volume_Creating Volume_StateEnum = 1
	Volume_Created  Volume_StateEnum = 2
	Volume_Deleting Volume_StateEnum = 3
	Volume_Deleted  Volume_StateEnum = 4
	Volume_Failed   Volume_StateEnum = 7
	Volume_Updating Volume_StateEnum = 8
)

var Volume_StateEnum_name = map[int32]string{
	0: "Unknown",
	1: "Creating",
	2: "Created",
	3: "Deleting",
	4: "Deleted",
	7: "Failed",
	8: "Updating",
}

var Volume_StateEnum_value = map[string]int32{
	"Unknown":  0,
	"Creating": 1,
	"Created":  2,
	"Deleting": 3,
	"Deleted":  4,
	"Failed":   7,
	"Updating": 8,
}

func (x Volume_StateEnum) String() string {
	return proto.EnumName(Volume_StateEnum_name, int32(x))
}

func (Volume_StateEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa16fa2085166c06, []int{2, 0}
}

type ClusterVolume_VolumeState int32

const (
	ClusterVolume_Active   ClusterVolume_VolumeState = 0
	ClusterVolume_Deleting ClusterVolume_VolumeState = 1
)

var ClusterVolume_VolumeState_name = map[int32]string{
	0: "Active",
	1: "Deleting",
}

var ClusterVolume_VolumeState_value = map[string]int32{
	"Active":   0,
	"Deleting": 1,
}

func (x ClusterVolume_VolumeState) String() string {
	return proto.EnumName(ClusterVolume_VolumeState_name, int32(x))
}

func (ClusterVolume_VolumeState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa16fa2085166c06, []int{6, 0}
}

type DurosVolume struct {
	// UUID of the namespace
	//
	// Should be used as uuid for nvme namespace
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// uuid of the protection group this volume belongs to.
	ProtectionGroupID string                   `protobuf:"bytes,2,opt,name=protectionGroupID,proto3" json:"protectionGroupID,omitempty"`
	Nsid              uint32                   `protobuf:"varint,3,opt,name=nsid,proto3" json:"nsid,omitempty"`
	NSIDVersion       uint32                   `protobuf:"varint,10,opt,name=NSIDVersion,proto3" json:"NSIDVersion,omitempty"`
	Acl               *StringList              `protobuf:"bytes,4,opt,name=acl,proto3" json:"acl,omitempty"`
	Compression       bool                     `protobuf:"varint,5,opt,name=compression,proto3" json:"compression,omitempty"`
	Protocol          DurosVolume_ProtocolEnum `protobuf:"varint,6,opt,name=protocol,proto3,enum=lightbits.api.volume.v1.DurosVolume_ProtocolEnum" json:"protocol,omitempty"`
	// capacity in bytes
	Size                 uint64      `protobuf:"varint,7,opt,name=size,proto3" json:"size,omitempty"`
	Name                 string      `protobuf:"bytes,8,opt,name=Name,proto3" json:"Name,omitempty"`
	RebuildProgress      string      `protobuf:"bytes,9,opt,name=RebuildProgress,proto3" json:"RebuildProgress,omitempty"`
	IPAcl                *StringList `protobuf:"bytes,11,opt,name=IPAcl,proto3" json:"IPAcl,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *DurosVolume) Reset()         { *m = DurosVolume{} }
func (m *DurosVolume) String() string { return proto.CompactTextString(m) }
func (*DurosVolume) ProtoMessage()    {}
func (*DurosVolume) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa16fa2085166c06, []int{0}
}

func (m *DurosVolume) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DurosVolume.Unmarshal(m, b)
}
func (m *DurosVolume) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DurosVolume.Marshal(b, m, deterministic)
}
func (m *DurosVolume) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DurosVolume.Merge(m, src)
}
func (m *DurosVolume) XXX_Size() int {
	return xxx_messageInfo_DurosVolume.Size(m)
}
func (m *DurosVolume) XXX_DiscardUnknown() {
	xxx_messageInfo_DurosVolume.DiscardUnknown(m)
}

var xxx_messageInfo_DurosVolume proto.InternalMessageInfo

func (m *DurosVolume) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

func (m *DurosVolume) GetProtectionGroupID() string {
	if m != nil {
		return m.ProtectionGroupID
	}
	return ""
}

func (m *DurosVolume) GetNsid() uint32 {
	if m != nil {
		return m.Nsid
	}
	return 0
}

func (m *DurosVolume) GetNSIDVersion() uint32 {
	if m != nil {
		return m.NSIDVersion
	}
	return 0
}

func (m *DurosVolume) GetAcl() *StringList {
	if m != nil {
		return m.Acl
	}
	return nil
}

func (m *DurosVolume) GetCompression() bool {
	if m != nil {
		return m.Compression
	}
	return false
}

func (m *DurosVolume) GetProtocol() DurosVolume_ProtocolEnum {
	if m != nil {
		return m.Protocol
	}
	return DurosVolume_ProtocolTCP
}

func (m *DurosVolume) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *DurosVolume) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DurosVolume) GetRebuildProgress() string {
	if m != nil {
		return m.RebuildProgress
	}
	return ""
}

func (m *DurosVolume) GetIPAcl() *StringList {
	if m != nil {
		return m.IPAcl
	}
	return nil
}

type Host struct {
	TypeMeta             *TypeMeta `protobuf:"bytes,1,opt,name=typeMeta,proto3" json:"typeMeta,omitempty"`
	HostNQN              string    `protobuf:"bytes,2,opt,name=hostNQN,proto3" json:"hostNQN,omitempty"`
	Address              string    `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	Hostname             string    `protobuf:"bytes,4,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Volumes              []string  `protobuf:"bytes,5,rep,name=volumes,proto3" json:"volumes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Host) Reset()         { *m = Host{} }
func (m *Host) String() string { return proto.CompactTextString(m) }
func (*Host) ProtoMessage()    {}
func (*Host) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa16fa2085166c06, []int{1}
}

func (m *Host) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Host.Unmarshal(m, b)
}
func (m *Host) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Host.Marshal(b, m, deterministic)
}
func (m *Host) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Host.Merge(m, src)
}
func (m *Host) XXX_Size() int {
	return xxx_messageInfo_Host.Size(m)
}
func (m *Host) XXX_DiscardUnknown() {
	xxx_messageInfo_Host.DiscardUnknown(m)
}

var xxx_messageInfo_Host proto.InternalMessageInfo

func (m *Host) GetTypeMeta() *TypeMeta {
	if m != nil {
		return m.TypeMeta
	}
	return nil
}

func (m *Host) GetHostNQN() string {
	if m != nil {
		return m.HostNQN
	}
	return ""
}

func (m *Host) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Host) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Host) GetVolumes() []string {
	if m != nil {
		return m.Volumes
	}
	return nil
}

type Volume struct {
	TypeMeta    *TypeMeta        `protobuf:"bytes,1,opt,name=typeMeta,proto3" json:"typeMeta,omitempty"`
	State       Volume_StateEnum `protobuf:"varint,2,opt,name=state,proto3,enum=lightbits.api.volume.v1.Volume_StateEnum" json:"state,omitempty"`
	DurosVolume *DurosVolume     `protobuf:"bytes,3,opt,name=durosVolume,proto3" json:"durosVolume,omitempty"`
	// user requirement for placing this volume in the correct PG.
	//
	// the user will specify the replicas count for
	ReplicaCount uint32 `protobuf:"varint,4,opt,name=replicaCount,proto3" json:"replicaCount,omitempty"`
	// Minimum replication before this volume turns to read only.
	//
	// case the volume is replicated
	MinimumReplicasCount uint32 `protobuf:"varint,5,opt,name=minimumReplicasCount,proto3" json:"minimumReplicasCount,omitempty"`
	// Peer list storing the volume
	NodeList             []string `protobuf:"bytes,6,rep,name=nodeList,proto3" json:"nodeList,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Volume) Reset()         { *m = Volume{} }
func (m *Volume) String() string { return proto.CompactTextString(m) }
func (*Volume) ProtoMessage()    {}
func (*Volume) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa16fa2085166c06, []int{2}
}

func (m *Volume) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Volume.Unmarshal(m, b)
}
func (m *Volume) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Volume.Marshal(b, m, deterministic)
}
func (m *Volume) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Volume.Merge(m, src)
}
func (m *Volume) XXX_Size() int {
	return xxx_messageInfo_Volume.Size(m)
}
func (m *Volume) XXX_DiscardUnknown() {
	xxx_messageInfo_Volume.DiscardUnknown(m)
}

var xxx_messageInfo_Volume proto.InternalMessageInfo

func (m *Volume) GetTypeMeta() *TypeMeta {
	if m != nil {
		return m.TypeMeta
	}
	return nil
}

func (m *Volume) GetState() Volume_StateEnum {
	if m != nil {
		return m.State
	}
	return Volume_Unknown
}

func (m *Volume) GetDurosVolume() *DurosVolume {
	if m != nil {
		return m.DurosVolume
	}
	return nil
}

func (m *Volume) GetReplicaCount() uint32 {
	if m != nil {
		return m.ReplicaCount
	}
	return 0
}

func (m *Volume) GetMinimumReplicasCount() uint32 {
	if m != nil {
		return m.MinimumReplicasCount
	}
	return 0
}

func (m *Volume) GetNodeList() []string {
	if m != nil {
		return m.NodeList
	}
	return nil
}

type VolumeState struct {
	TypeMeta             *TypeMeta        `protobuf:"bytes,1,opt,name=typeMeta,proto3" json:"typeMeta,omitempty"`
	State                Volume_StateEnum `protobuf:"varint,2,opt,name=state,proto3,enum=lightbits.api.volume.v1.Volume_StateEnum" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *VolumeState) Reset()         { *m = VolumeState{} }
func (m *VolumeState) String() string { return proto.CompactTextString(m) }
func (*VolumeState) ProtoMessage()    {}
func (*VolumeState) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa16fa2085166c06, []int{3}
}

func (m *VolumeState) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeState.Unmarshal(m, b)
}
func (m *VolumeState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeState.Marshal(b, m, deterministic)
}
func (m *VolumeState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeState.Merge(m, src)
}
func (m *VolumeState) XXX_Size() int {
	return xxx_messageInfo_VolumeState.Size(m)
}
func (m *VolumeState) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeState.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeState proto.InternalMessageInfo

func (m *VolumeState) GetTypeMeta() *TypeMeta {
	if m != nil {
		return m.TypeMeta
	}
	return nil
}

func (m *VolumeState) GetState() Volume_StateEnum {
	if m != nil {
		return m.State
	}
	return Volume_Unknown
}

type VolumeCreated struct {
	Volume               *Volume  `protobuf:"bytes,1,opt,name=volume,proto3" json:"volume,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeCreated) Reset()         { *m = VolumeCreated{} }
func (m *VolumeCreated) String() string { return proto.CompactTextString(m) }
func (*VolumeCreated) ProtoMessage()    {}
func (*VolumeCreated) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa16fa2085166c06, []int{4}
}

func (m *VolumeCreated) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeCreated.Unmarshal(m, b)
}
func (m *VolumeCreated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeCreated.Marshal(b, m, deterministic)
}
func (m *VolumeCreated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeCreated.Merge(m, src)
}
func (m *VolumeCreated) XXX_Size() int {
	return xxx_messageInfo_VolumeCreated.Size(m)
}
func (m *VolumeCreated) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeCreated.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeCreated proto.InternalMessageInfo

func (m *VolumeCreated) GetVolume() *Volume {
	if m != nil {
		return m.Volume
	}
	return nil
}

// This structure is the internal represtnation that cluster manager will in
// produced by the api-service for the cluster-manager to process.
type NodeCreateVolumeCommand struct {
	TypeMeta *TypeMeta `protobuf:"bytes,1,opt,name=typeMeta,proto3" json:"typeMeta,omitempty"`
	// Command ID for tracability and debug
	UUID string `protobuf:"bytes,2,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// Aggregation of events that CM recieve about this command.
	Events []*Event `protobuf:"bytes,3,rep,name=Events,proto3" json:"Events,omitempty"`
	// A copy of the volume that
	Volume               *Volume  `protobuf:"bytes,4,opt,name=volume,proto3" json:"volume,omitempty"`
	Name                 string   `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeCreateVolumeCommand) Reset()         { *m = NodeCreateVolumeCommand{} }
func (m *NodeCreateVolumeCommand) String() string { return proto.CompactTextString(m) }
func (*NodeCreateVolumeCommand) ProtoMessage()    {}
func (*NodeCreateVolumeCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa16fa2085166c06, []int{5}
}

func (m *NodeCreateVolumeCommand) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeCreateVolumeCommand.Unmarshal(m, b)
}
func (m *NodeCreateVolumeCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeCreateVolumeCommand.Marshal(b, m, deterministic)
}
func (m *NodeCreateVolumeCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeCreateVolumeCommand.Merge(m, src)
}
func (m *NodeCreateVolumeCommand) XXX_Size() int {
	return xxx_messageInfo_NodeCreateVolumeCommand.Size(m)
}
func (m *NodeCreateVolumeCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeCreateVolumeCommand.DiscardUnknown(m)
}

var xxx_messageInfo_NodeCreateVolumeCommand proto.InternalMessageInfo

func (m *NodeCreateVolumeCommand) GetTypeMeta() *TypeMeta {
	if m != nil {
		return m.TypeMeta
	}
	return nil
}

func (m *NodeCreateVolumeCommand) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

func (m *NodeCreateVolumeCommand) GetEvents() []*Event {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *NodeCreateVolumeCommand) GetVolume() *Volume {
	if m != nil {
		return m.Volume
	}
	return nil
}

func (m *NodeCreateVolumeCommand) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ClusterVolume struct {
	TypeMeta            *TypeMeta   `protobuf:"bytes,1,opt,name=typeMeta,proto3" json:"typeMeta,omitempty"`
	UUID                string      `protobuf:"bytes,2,opt,name=UUID,proto3" json:"UUID,omitempty"`
	NSID                uint32      `protobuf:"varint,3,opt,name=NSID,proto3" json:"NSID,omitempty"`
	ProtectionGroupUUID string      `protobuf:"bytes,4,opt,name=ProtectionGroupUUID,proto3" json:"ProtectionGroupUUID,omitempty"`
	ACL                 *StringList `protobuf:"bytes,5,opt,name=ACL,proto3" json:"ACL,omitempty"`
	IPACL               *StringList `protobuf:"bytes,6,opt,name=IPACL,proto3" json:"IPACL,omitempty"`
	Compression         bool        `protobuf:"varint,7,opt,name=Compression,proto3" json:"Compression,omitempty"`
	// Capacity of the volume in bytes
	Size uint64 `protobuf:"varint,8,opt,name=Size,proto3" json:"Size,omitempty"`
	Name string `protobuf:"bytes,9,opt,name=Name,proto3" json:"Name,omitempty"`
	// Number of changes applied to the volume. Basically the same idea as
	// version of Protection Group.
	Version              uint64                    `protobuf:"varint,10,opt,name=Version,proto3" json:"Version,omitempty"`
	State                ClusterVolume_VolumeState `protobuf:"varint,11,opt,name=State,proto3,enum=lightbits.api.volume.v1.ClusterVolume_VolumeState" json:"State,omitempty"`
	NSIDVersion          uint32                    `protobuf:"varint,12,opt,name=NSIDVersion,proto3" json:"NSIDVersion,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *ClusterVolume) Reset()         { *m = ClusterVolume{} }
func (m *ClusterVolume) String() string { return proto.CompactTextString(m) }
func (*ClusterVolume) ProtoMessage()    {}
func (*ClusterVolume) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa16fa2085166c06, []int{6}
}

func (m *ClusterVolume) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClusterVolume.Unmarshal(m, b)
}
func (m *ClusterVolume) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClusterVolume.Marshal(b, m, deterministic)
}
func (m *ClusterVolume) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterVolume.Merge(m, src)
}
func (m *ClusterVolume) XXX_Size() int {
	return xxx_messageInfo_ClusterVolume.Size(m)
}
func (m *ClusterVolume) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterVolume.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterVolume proto.InternalMessageInfo

func (m *ClusterVolume) GetTypeMeta() *TypeMeta {
	if m != nil {
		return m.TypeMeta
	}
	return nil
}

func (m *ClusterVolume) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

func (m *ClusterVolume) GetNSID() uint32 {
	if m != nil {
		return m.NSID
	}
	return 0
}

func (m *ClusterVolume) GetProtectionGroupUUID() string {
	if m != nil {
		return m.ProtectionGroupUUID
	}
	return ""
}

func (m *ClusterVolume) GetACL() *StringList {
	if m != nil {
		return m.ACL
	}
	return nil
}

func (m *ClusterVolume) GetIPACL() *StringList {
	if m != nil {
		return m.IPACL
	}
	return nil
}

func (m *ClusterVolume) GetCompression() bool {
	if m != nil {
		return m.Compression
	}
	return false
}

func (m *ClusterVolume) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *ClusterVolume) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ClusterVolume) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *ClusterVolume) GetState() ClusterVolume_VolumeState {
	if m != nil {
		return m.State
	}
	return ClusterVolume_Active
}

func (m *ClusterVolume) GetNSIDVersion() uint32 {
	if m != nil {
		return m.NSIDVersion
	}
	return 0
}

type NodeVolume struct {
	TypeMeta *TypeMeta `protobuf:"bytes,1,opt,name=typeMeta,proto3" json:"typeMeta,omitempty"`
	UUID     string    `protobuf:"bytes,2,opt,name=UUID,proto3" json:"UUID,omitempty"`
	NodeUUID string    `protobuf:"bytes,3,opt,name=NodeUUID,proto3" json:"NodeUUID,omitempty"`
	// Number of changes applied to the volume by Node Manager
	Version              uint64   `protobuf:"varint,4,opt,name=Version,proto3" json:"Version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeVolume) Reset()         { *m = NodeVolume{} }
func (m *NodeVolume) String() string { return proto.CompactTextString(m) }
func (*NodeVolume) ProtoMessage()    {}
func (*NodeVolume) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa16fa2085166c06, []int{7}
}

func (m *NodeVolume) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeVolume.Unmarshal(m, b)
}
func (m *NodeVolume) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeVolume.Marshal(b, m, deterministic)
}
func (m *NodeVolume) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeVolume.Merge(m, src)
}
func (m *NodeVolume) XXX_Size() int {
	return xxx_messageInfo_NodeVolume.Size(m)
}
func (m *NodeVolume) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeVolume.DiscardUnknown(m)
}

var xxx_messageInfo_NodeVolume proto.InternalMessageInfo

func (m *NodeVolume) GetTypeMeta() *TypeMeta {
	if m != nil {
		return m.TypeMeta
	}
	return nil
}

func (m *NodeVolume) GetUUID() string {
	if m != nil {
		return m.UUID
	}
	return ""
}

func (m *NodeVolume) GetNodeUUID() string {
	if m != nil {
		return m.NodeUUID
	}
	return ""
}

func (m *NodeVolume) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func init() {
	proto.RegisterEnum("lightbits.api.volume.v1.ProtectionStateEnum", ProtectionStateEnum_name, ProtectionStateEnum_value)
	proto.RegisterEnum("lightbits.api.volume.v1.DurosVolume_ProtocolEnum", DurosVolume_ProtocolEnum_name, DurosVolume_ProtocolEnum_value)
	proto.RegisterEnum("lightbits.api.volume.v1.Volume_StateEnum", Volume_StateEnum_name, Volume_StateEnum_value)
	proto.RegisterEnum("lightbits.api.volume.v1.ClusterVolume_VolumeState", ClusterVolume_VolumeState_name, ClusterVolume_VolumeState_value)
	proto.RegisterType((*DurosVolume)(nil), "lightbits.api.volume.v1.DurosVolume")
	proto.RegisterType((*Host)(nil), "lightbits.api.volume.v1.Host")
	proto.RegisterType((*Volume)(nil), "lightbits.api.volume.v1.Volume")
	proto.RegisterType((*VolumeState)(nil), "lightbits.api.volume.v1.VolumeState")
	proto.RegisterType((*VolumeCreated)(nil), "lightbits.api.volume.v1.VolumeCreated")
	proto.RegisterType((*NodeCreateVolumeCommand)(nil), "lightbits.api.volume.v1.NodeCreateVolumeCommand")
	proto.RegisterType((*ClusterVolume)(nil), "lightbits.api.volume.v1.ClusterVolume")
	proto.RegisterType((*NodeVolume)(nil), "lightbits.api.volume.v1.NodeVolume")
}

func init() { proto.RegisterFile("common_apis/volume.proto", fileDescriptor_fa16fa2085166c06) }

var fileDescriptor_fa16fa2085166c06 = []byte{
	// 960 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0x5f, 0xd7, 0xce, 0x9f, 0x3e, 0xa7, 0x5d, 0x33, 0xac, 0x54, 0x93, 0xcb, 0x5a, 0x16, 0x12,
	0x01, 0xb6, 0x09, 0x9b, 0x3d, 0x70, 0xe0, 0x80, 0x42, 0xb2, 0xa5, 0x11, 0xd9, 0x10, 0x9c, 0xed,
	0x1e, 0xb8, 0xac, 0x26, 0xf1, 0xc8, 0x1d, 0x61, 0xcf, 0x58, 0xf6, 0x38, 0xab, 0x72, 0xe5, 0xc8,
	0xd7, 0x80, 0xcf, 0xc2, 0xa7, 0xe0, 0x63, 0x70, 0x47, 0x33, 0xe3, 0x64, 0x27, 0xdd, 0x96, 0x42,
	0x41, 0xe2, 0xf6, 0xde, 0xfb, 0xbd, 0xf7, 0xfc, 0xfe, 0xcc, 0xfc, 0xc6, 0xe0, 0xaf, 0x79, 0x96,
	0x71, 0xf6, 0x1a, 0xe7, 0xb4, 0x1c, 0x6c, 0x78, 0x5a, 0x65, 0xa4, 0x9f, 0x17, 0x5c, 0x70, 0x74,
	0x92, 0xd2, 0xe4, 0x52, 0xac, 0xa8, 0x28, 0xfb, 0x38, 0xa7, 0xfd, 0x1a, 0xdb, 0x3c, 0xed, 0x3e,
	0x51, 0xf8, 0xfa, 0x34, 0x21, 0xec, 0xb4, 0x7c, 0x83, 0x93, 0x84, 0x14, 0x03, 0x9e, 0x0b, 0xca,
	0x59, 0x39, 0xc0, 0x8c, 0x71, 0x81, 0x95, 0xac, 0xd3, 0x74, 0x03, 0xf3, 0x03, 0xac, 0x4a, 0x53,
	0xbc, 0x4a, 0xc9, 0x6b, 0x71, 0x95, 0x93, 0xad, 0x47, 0xd7, 0xf4, 0x90, 0x40, 0x46, 0x04, 0xae,
	0xb1, 0xbd, 0xf2, 0xc8, 0x86, 0x30, 0x51, 0x47, 0x85, 0xbf, 0xd9, 0xe0, 0x4e, 0xaa, 0x82, 0x97,
	0xaf, 0x54, 0x61, 0x08, 0x81, 0x73, 0x71, 0x31, 0x9d, 0xf8, 0x56, 0x60, 0xf5, 0x0e, 0x23, 0x25,
	0xa3, 0x27, 0xf0, 0x9e, 0x74, 0x26, 0x6b, 0x59, 0xd0, 0xd7, 0x05, 0xaf, 0xf2, 0xe9, 0xc4, 0x3f,
	0x50, 0x0e, 0xef, 0x02, 0x32, 0x03, 0x2b, 0x69, 0xec, 0xdb, 0x81, 0xd5, 0x3b, 0x8a, 0x94, 0x8c,
	0x02, 0x70, 0xe7, 0xcb, 0xe9, 0xe4, 0x15, 0x29, 0x4a, 0xca, 0x99, 0x0f, 0x0a, 0x32, 0x4d, 0xe8,
	0x53, 0xb0, 0xf1, 0x3a, 0xf5, 0x9d, 0xc0, 0xea, 0xb9, 0xc3, 0x0f, 0xfa, 0xfb, 0x43, 0x5b, 0x8a,
	0x82, 0xb2, 0x64, 0x46, 0x4b, 0x11, 0x49, 0x2f, 0x99, 0x6e, 0xcd, 0xb3, 0xbc, 0x20, 0xa5, 0x4a,
	0xd7, 0x08, 0xac, 0x5e, 0x3b, 0x32, 0x4d, 0xe8, 0x05, 0xb4, 0xf5, 0x78, 0x79, 0xea, 0x37, 0x03,
	0xab, 0x77, 0x3c, 0x7c, 0xda, 0xbf, 0x65, 0x11, 0x7d, 0xa3, 0xfd, 0xfe, 0xa2, 0x0e, 0x7a, 0xce,
	0xaa, 0x2c, 0xda, 0xa5, 0x90, 0x3d, 0x95, 0xf4, 0x47, 0xe2, 0xb7, 0x02, 0xab, 0xe7, 0x44, 0x4a,
	0x96, 0xb6, 0x39, 0xce, 0x88, 0xdf, 0xd6, 0x93, 0x92, 0x32, 0xea, 0xc1, 0xc3, 0x88, 0xac, 0x2a,
	0x9a, 0xc6, 0x8b, 0x82, 0x27, 0xb2, 0x18, 0xff, 0x50, 0xc1, 0xd7, 0xcd, 0x68, 0x00, 0x8d, 0xe9,
	0x62, 0xb4, 0x4e, 0x7d, 0xf7, 0xae, 0x8e, 0xb5, 0x5f, 0xf8, 0x18, 0x3a, 0x66, 0x71, 0xe8, 0x21,
	0xb8, 0x5b, 0xfd, 0xe5, 0x78, 0xe1, 0x3d, 0x08, 0x7f, 0xb5, 0xc0, 0x39, 0xe7, 0xa5, 0x40, 0xcf,
	0xa0, 0x2d, 0xd7, 0xff, 0x82, 0x08, 0xac, 0xd6, 0xe8, 0x0e, 0x4f, 0xae, 0x65, 0x7f, 0x59, 0xc3,
	0xd1, 0xce, 0x11, 0xf9, 0xd0, 0xba, 0xe4, 0xa5, 0x98, 0x7f, 0x37, 0xaf, 0x37, 0xbb, 0x55, 0x25,
	0x82, 0xe3, 0x58, 0xf5, 0x62, 0x6b, 0xa4, 0x56, 0x51, 0x17, 0xda, 0xd2, 0x89, 0xc9, 0x29, 0x38,
	0x0a, 0xda, 0xe9, 0x32, 0x4a, 0x4f, 0xb8, 0xf4, 0x1b, 0x81, 0x2d, 0xa3, 0x6a, 0x35, 0xfc, 0xc5,
	0x86, 0x66, 0x7d, 0xd8, 0xee, 0x55, 0xe9, 0x97, 0xd0, 0x28, 0x05, 0x16, 0x44, 0xd5, 0x79, 0x3c,
	0xfc, 0xf8, 0xd6, 0xbd, 0xd6, 0x2b, 0x5d, 0x4a, 0x67, 0xb5, 0x4f, 0x1d, 0x87, 0xce, 0xc0, 0x8d,
	0xdf, 0xae, 0x5c, 0x35, 0xe5, 0x0e, 0x3f, 0xfc, 0x3b, 0xc7, 0x23, 0x32, 0x03, 0x51, 0x08, 0x9d,
	0x82, 0xe4, 0x29, 0x5d, 0xe3, 0x31, 0xaf, 0x98, 0x50, 0x23, 0x38, 0x8a, 0xf6, 0x6c, 0x68, 0x08,
	0x8f, 0x32, 0xca, 0x68, 0x56, 0x65, 0x91, 0x36, 0x97, 0xda, 0xb7, 0xa1, 0x7c, 0x6f, 0xc4, 0xe4,
	0x58, 0x19, 0x8f, 0x89, 0x5c, 0xbe, 0xdf, 0x54, 0xb3, 0xdb, 0xe9, 0xe1, 0x25, 0x1c, 0xee, 0xfa,
	0x41, 0x2e, 0xb4, 0x2e, 0xd8, 0x0f, 0x8c, 0xbf, 0x61, 0xde, 0x03, 0xd4, 0x81, 0xf6, 0xb8, 0x20,
	0x58, 0x50, 0x96, 0x78, 0x96, 0x84, 0x94, 0x46, 0x62, 0xef, 0x40, 0x42, 0x13, 0x92, 0x12, 0x05,
	0xd9, 0x12, 0x52, 0x1a, 0x89, 0x3d, 0x07, 0x01, 0x34, 0xcf, 0x30, 0x4d, 0x49, 0xec, 0xb5, 0xa4,
	0xdb, 0x45, 0x1e, 0xeb, 0x0c, 0xed, 0xf0, 0x27, 0x0b, 0x5c, 0xdd, 0xa8, 0xfa, 0xe0, 0xff, 0xb3,
	0xab, 0xf0, 0x1c, 0x8e, 0x34, 0x54, 0x77, 0x83, 0x3e, 0x87, 0xa6, 0x8e, 0xaa, 0x8b, 0x78, 0x7c,
	0x47, 0xca, 0xa8, 0x76, 0x0f, 0x7f, 0xb7, 0xe0, 0x64, 0xce, 0xe3, 0x3a, 0x51, 0x9d, 0x94, 0x67,
	0x19, 0x66, 0xf1, 0xfd, 0x7a, 0xdb, 0x32, 0xe5, 0xc1, 0x1e, 0x53, 0x36, 0x9f, 0x2b, 0x76, 0xf5,
	0xed, 0xc0, 0xee, 0xb9, 0xc3, 0x47, 0xd7, 0xd2, 0x28, 0x30, 0xaa, 0x7d, 0x8c, 0x5e, 0x9c, 0x7f,
	0xd4, 0x8b, 0xa2, 0x58, 0x79, 0xe9, 0x1a, 0xfa, 0xd3, 0x52, 0x0e, 0xff, 0xb0, 0xe1, 0x68, 0x9c,
	0x56, 0xa5, 0x20, 0xc5, 0xbf, 0xb9, 0x5d, 0x37, 0x75, 0x25, 0x99, 0x6e, 0x39, 0x9d, 0x6c, 0x19,
	0x5d, 0xca, 0xe8, 0x33, 0x78, 0x7f, 0xb1, 0x4f, 0xfd, 0x2a, 0x4c, 0xd3, 0xc0, 0x4d, 0x90, 0x64,
	0xf8, 0xd1, 0x78, 0xa6, 0x6a, 0xfe, 0x6b, 0x86, 0x1f, 0x8d, 0x67, 0x35, 0x3d, 0x8e, 0x67, 0x8a,
	0xbc, 0xef, 0xa4, 0xc7, 0xf1, 0x4c, 0x3e, 0x09, 0x63, 0xe3, 0x49, 0x68, 0xe9, 0x27, 0xc1, 0x30,
	0xc9, 0x2e, 0x96, 0x92, 0xc3, 0xdb, 0x9a, 0xc3, 0x97, 0x26, 0x87, 0x1f, 0x1a, 0x1c, 0xee, 0x43,
	0xcb, 0x7c, 0xa7, 0x9c, 0x68, 0xab, 0xa2, 0x73, 0x68, 0xa8, 0x03, 0xaa, 0x38, 0xfb, 0x78, 0x38,
	0xbc, 0x75, 0x5d, 0x7b, 0x7b, 0xe8, 0x1b, 0xb7, 0x28, 0xd2, 0x09, 0xae, 0xbf, 0x87, 0x9d, 0x77,
	0xde, 0xc3, 0xf0, 0xa3, 0xfd, 0xdb, 0x07, 0xd0, 0x1c, 0xad, 0x05, 0xdd, 0x10, 0x7d, 0xd3, 0x77,
	0xd7, 0xd9, 0x0a, 0x7f, 0xb6, 0x00, 0xe4, 0xb9, 0xfe, 0xaf, 0x97, 0xde, 0x85, 0xb6, 0x4c, 0xab,
	0xec, 0x9a, 0xf7, 0x77, 0xba, 0x39, 0x22, 0x67, 0x6f, 0x44, 0x9f, 0xc4, 0xe6, 0xb1, 0xb8, 0x85,
	0xa9, 0x10, 0x1c, 0x9f, 0x55, 0x69, 0x7a, 0x55, 0x3b, 0x92, 0xd8, 0xb3, 0x74, 0x4f, 0x49, 0x81,
	0xe3, 0x2d, 0x61, 0x45, 0x04, 0xc7, 0xdf, 0xb2, 0xf4, 0xca, 0xb3, 0x91, 0x07, 0x9d, 0x39, 0x17,
	0xa3, 0x0d, 0xa6, 0xea, 0xa7, 0xc7, 0x73, 0xbe, 0xfa, 0xe6, 0xfb, 0x69, 0x42, 0xc5, 0x65, 0xb5,
	0xea, 0xaf, 0x79, 0x36, 0xd8, 0xb5, 0x97, 0xe2, 0x55, 0xf9, 0x56, 0x3b, 0xc5, 0x39, 0x1d, 0x24,
	0x84, 0x0d, 0x12, 0x9e, 0x62, 0x96, 0x0c, 0x8c, 0x5f, 0xa0, 0x2f, 0x0c, 0x79, 0xd5, 0x54, 0xaf,
	0xfc, 0xb3, 0x3f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x1c, 0x44, 0x85, 0x55, 0xc3, 0x09, 0x00, 0x00,
}
